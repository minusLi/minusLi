# 内存对齐
### 内存对齐是什么？
```
// 64 位系统
type A struct {
	x byte
	y int64
}
// A 的实例占用多大空间？
// 答案是 16 字节，不是 1+8=9 字节
// 原因：内存对齐，对齐规则如下
// 1. 成员偏移量必须是当前成员大小的整数倍；
// 2. 整个结构体必须是最大成员大小的整数倍；
// 3. #pragma pack(n)，可干预，指定 n 字节对齐；
```

### 为什么要内存对齐？
背景： 64 位系统寻址每次只能从 8*n 位置获取数据；

方向思考：假设没有内存对齐？  
> 存储方式：地址中 0-1 字节存放的是 x，1-9 字节存放的 y；
> 
> 现在假设读取 x，则需要读取 0 位置，读取 1 个字节，即 0-1 字节；
> 
> 现在假设读取 y，则需要读取 0 位置，读取 8 个字节，即 0-8 字节；然后剔除 0-1 字节；  
> 
> 这个时候，并没有读取完 y，因为 y 还有部分在 8-9 的位置；
> 
> 所以接下来，还要读取 8-9 字节；将这部分和之前加载的 1-7 做合并，一同加载到寄存器中；
> 
> 总结：读取 x 加载 1 次；读取 y 总共加载了 2 次，剔除了 1 次，最后还有 1 次合并；

正向思考：有内存对齐！
> 存储方式：地址中 0-8 字节存放的是 x，8-16 字节存放的 y；
> 
> 现在假设读取 x，则需要读取 0 位置，读取 8 个字节，即 0-1 字节；
> 
> 现在假设读取 y，则需要读取 8 位置，读取 8 个字节，即 8-16 字节；无需剔除；
> 
> 总结：读取 x 加载 1 次；读取 y 也是加载 1 次；

可以看到有无内存对齐的读取过程上，y 的读取明显减少了多次操作；

上面说的是出于性能考虑，内存对齐的原因；其实还有出于硬件原因，因为不是所有硬件平台都能随意访问任何地址上的任何数据的，这些平台遇到未对齐的情况会直接直接抛出硬件异常；

扩展：
- 内存对齐，有效的减少了数据加载的操作过程，提高了速度；但引入的问题就是引入了很多的内存碎片；
- 折中方式：不会给每个变量都对齐首地址，而是尽可能让变量的加载在一次以内（提出操作速度是非常快的，所以允许剔除，减少加载）
- 具体做法：有些编译器会调整 struct 变量顺序，减少因为内存对齐引入的碎片，同时尽可能少的次数去加载数据；
